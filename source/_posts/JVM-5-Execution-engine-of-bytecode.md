---
title: 'JVM(5):字节码执行引擎'
date: 2017-12-14 13:41:54
toc: true
tags:
 - JVM
 - 学习笔记
---

  经历过类加载以后，类文件结构就以JVM定义的形式存储在JVM的方法区中。但是程序如何执行的描述存储在我们前面介绍的方法表的Code属性中的字节码指令，字节码执行引擎，即是执行那些直接码指令，以至于让程序“跑”起来。字节码执行引擎相当于JVM的“处理器”。

  实际上JVM规范只定义了字节码执行引擎的概念模型，具体的实现可能是解释执行也可能是编译执行，或者混合起来。但是从外面看，所有的字节码执行引擎输入都是字节码文件，处理后输出的都是执行结果。

## 运行时栈帧结构

  JVM的直接码指令是基于栈操作的，我们也知道在JVM的内存结构里，线程私有的3种内存，即虚拟机栈，本地方法栈，和程序计数器。Hotspot中没有本地方法栈和虚拟机栈的区别，在JVM里，这两种栈中的元素都被称之为**栈帧**。栈帧是VM进行方法调用和方法执行的数据结构，它存储了方法的**局部变量表，操作数栈，动态链接和方法返回地址和一些附加信息**。

<!--more-->

  我们之前介绍过方法表的Code属性，你知道它是干嘛的，现在我要说的是，栈帧就是来源于Code属性，我们在这里再看一遍Code属性的具体结构：

```
Code_attribute {
    u2 attribute_name_index;//固定指向值为Code的一个CONSTANT_Utf8_info
    u4 attribute_length;
    /*info部分*/
    u2 max_stack;//操作数栈的最大深度
    u2 max_locals;//局部变量表的存储空间，单位Slot(4个字节)
    /*代码部分*/
    u4 code_length;
    u1 code[code_length];
    /*显示异常处理表部分*/
    u2 exception_table_length;
    exception_info exception_table[exception_table_length];
    /*属性表部分*/
    u2 attributes_count;
    attribute_info attributes[attributes_count];
}

exception_info{
	u2 start_pc;
	u2 end_pc;
	u2 handler_pc;
	u2 catch_type;
}
```

  仔细一看你可以发现Code属性中，把属于它的操作数栈的一些信息都给定死了，实际上却是如此，这些已经定下来的信息会映射到该方法在VM栈中对应的栈帧中。一个栈帧要分配多少内存，仅取决虚拟机的实现，因为运行期的变量所需的具体内存啥的，Code属性已经给你确定好了。

  你已经知道VM栈是一种**线程私有**的内存结构，每个线程一个，而当前线程执行的方法是由它的VM栈的栈顶元素决定的，栈顶元素又称为**当前方法**。执行引擎运行的所有字节码指令都是针对该线程的VM栈栈顶元素进行操作，准确来说是根据那个栈帧的**局部变量表，操作数栈，动态链接和方法返回地址和一些附加信息**进行操作。所以我们迫切需要知道五种数据结构是什么，介绍完之后我们才能来解释一个方法的调用过程。

### 局部变量表

  局部变量表和操作数栈其实我们在介绍Code的属性表里的StackMapTable属性时有过一些接触。另外Code属性中的max_locals字段限制的就是局部变量表的最大容量。

  局部变量表的最小容量单位也是Slot，我们在前面的文章中介绍过它，一个Slot一般是32位（这与虚拟机，操作系统有关）,既然是最小单位，那么像boolean，short这种定义上是低于32位的类型，其实在局部变量表中也是按一个Slot来分配的，64位的数据则以连续的两个Slot来表示。

  在介绍**类加载**的时候我们提到了**准备阶段**，这个阶段即是按类型对类变量赋默认值，相信如果你看了我的前一篇文章，应该还记得这一点，准备阶段的存在可以让类变量在没有赋值的情况下有一个默认值，但是方法中的局部变量可没有准备阶段这种东西。

```java
public static void main(String[] args){
		int m;
		System.out.println(m);
}
```

### 操作数栈

  现在我们知道在哪里存储我们的局部变量了，如果你写过一个逆波兰式的计算程序，那你肯定会接触到基于栈的一个计算方式，或许你当时并没有想太多，但是现在我可以告诉你**操作数栈**这个东西就和你当时做的那个小程序里的栈意义上是一样的，只不过我们我们的运算符已经是jvm直接码指令罢了，"基于栈的执行引擎"的名字由来就是操作数栈。

  操作数栈的单位容量也是32位的，如果一个数据类型是64位的那么就栈两个单位容量，这个我在介绍StackMapTable属性时也提到过，操作数栈的最大深度由Code属性中的max_stacks数据项给定。

  在周志明的书中提到过一个**VM栈帧（是虚拟机栈，不是操作数栈，注意）共享的概念**，就是在概念上完全独立的两个方法的VM栈帧，实际实现时，可能会出现前面一个栈帧的局部变量表与后面一个栈帧的操作数栈共用一部分内存区域的情况，这种情况发生在方法调用变量的传递时。

### 动态链接

  栈帧中存在一个指向运行池常量池的该栈帧所属方法的引用 ，这个引用的目的是为了支持**动态链接**。这个我们在类加载的解析阶段提到过，类的解析过程中并非所有的对类文件常量池的符号引用都转化为了直接引用，还有一部分是在运 行时转化，即**动态链接**。

### 方法返回地址

  在方法中调用另一个方法，被调用的方法无论是异常退出还是正常的完成都会涉及到一个返回之后，调用者方法从哪里继续的问题，如果是异常退出，则VM可以通过异常处理表来确定执行下一条指令的位置，如果是正常退出则就需要**方法返回地址**这个东西了，它主要是保存了调用时的线程的PC计数器的值。

  方法退出时当前帧出栈，然后恢复上层方法的局部变量表和操作数栈，有返回值的话还要把这个返回值压入操作数栈（如果是前面提到的**VM栈帧共享**，也可能不是这样做），然后要把PC计数器按照方法返回地址调整。

### 附加信息

  当然以上是JVM规范中强制要求的几个数据结构，有可能JVM自己需要添加一些信息，用于调试之类的操作，这类信息通通成为附加信息。

## 方法调用

  **方法调用阶段的唯一目的是确定被调用方法的版本。**

  在讨论**类文件结构**的时候你就已经知道，在Class文件中方法是以符号引用方式存在的，在类加载的解析过程中，一部分符号引用转化为了直接引用，但是还有一部分动态链接的方法只有等到运行时才能确定直接引用。为了在这些情况都能使得方法成功正确的调用，就有了这个**方法调用**阶段。

### 解析

  在类加载的解析阶段，能确定下来“编译期可知，运行期不可变”这个要求的方法，主要包括**静态方法**和**私有方法**两大类。聪明的人稍微想一下就知道了，静态方法是不可以重写的，而私有方法只能在内部访问，所以这两种方法根本不需要考虑会有什么动态变化之类的事情发生，对这两种方法的“版本”只有一种可能，在类编译期就可以确定，在解析阶段直接由符号引用变成直接引用。解析是一个静态过程。

### 分派

  首先我要说解析和分派并不是互斥的两个过程，然后我们讨论分派过程，**这个过程涉及到重载和重写在jvm中的实现，总的来说这个过程就是在进一步确定具体要调用那个方法**，我们首先来看看jvm中的方法调用指令。

  虚拟机调用方法的字节码有5条：

1. invokestatic：调用静态方法
2. invokespecial:调用实例构造器&lt;init&gt;,私有和父类方法。
3. invokevirtual：调用**虚方法**
4. invokeinterface：调用接口方法，运行期确定一个接口的实现对象
5. invokedynamic：在运行期对调用点限定符动态解析，然后执行该方法，该指令的**分派逻辑**由用户设定的引导方法决定。

  上面提到了两个说法：分派逻辑和虚方法，我们先来解释一下虚方法。

  invokestatic和invokespecial这两个指令调用的方法，都是在类解析阶段就可以确定其版本。除了上面说明的方法以外，final修饰的方法也是可以唯一确定的，稍微思考一下就知道。这些方法都称之为**非虚方法**，进行指令调用时你不需要考虑多态选择，一个方法不是**非虚的**就是**虚方法**。

分派，分派可以是**静态的也可以是动态的**。

#### 静态分派

静态分派是指依赖**静态类型** 来定位目标方法的分派动作。

静态类型的概念我们可以用一句代码来解释：

```java
Car car=new Benz();
```

上面的这句代码中Car就是静态类型，也称之为**外观类型**，外观类型这个词语可能更能让你有一个理解。而Benz则是**实际类型**。

那么什么是依赖静态类型来定位目标方法呢？

```java
public class Blue {
		  public static void startUp(Car car){
		    System.out.println("You startup a car");
		  }

		  public static void startUp(Benz benz){
		    System.out.println("You startup a benz");
		  }
		  
		  public static void main(String[] args){
		      Car benz=new Benz();
		      startUp(benz);
		  }
}

class Car{}
class Benz extends Car{};
```

对于上面的代码我们输出了"You startup a car"，即它是按照静态类型Car来确定该调用哪个方法的，所以这就是**静态分派**。

静态类型是编译器可知的，在编译期间编译器就会根据静态类型来决定使用哪个重载版本，如果你学过C++的话，那么那本基础书上应该非常明白的翻来覆去的讲过“运行期多态”和“编译期多态”。

  实际上不同的jvm上语言对静态分派的态度也不同，有时候，特别是用了...符号的变长参数的时候，有可能会产生多个分派结果都符合要求的情况，javac往往会用自己定义的规则来选择一个分派，然而scalac就直接报错了，会提示一个不允许混淆的错误，实际上javac的做法我个人认为有时会让编程者感到很疑惑。

#### 动态分派

  动态分派涉及到重写，这个应该是常见面试题了，我们这里就不列出代码了。

  动态分派根据实际类型来确定方法，现在我要说明的就是具体的执行过程。首先我们先来认识一下jvm中的多态查找，该过程实际上就是invokevirtual指令的执行过程，也是java语言中重写的本质：

1. 首先找到操作数栈栈顶元素所指向对象的**实际类型** ：C。
2. 如果在C中找到与常量中的**描述符和简单名称** 都相同的方法，就验证访问权限，如果通过就返回该方法的直接引用，不通过者抛出java.lang.IllegalAccessError异常
3. 否则递归的寻找父类中的对应方法，如果递归到最后的Object还没有找到就抛出java.lang.AbstractMethodError异常。

#### 单分派与多分派

  我们把目标方法的所有者类型，称之为方法的**接收者**。

  接受者和方法的参数统称为方法的宗量。多分派和单分派的区别就在于是不是方法选择是否是根据多个总量而定的，若不是则为单分派。

```java
class Benz extends Car{

	@Override
	public void sayHello(Car car) {
		System.out.println("hello,Benz");
	}

	@Override
	public void sayHello(Benz benz) {
		System.out.println("hi,benz");
	}
	
	public static void main(String[] args) {
		Car car=new Benz();
		car.sayHello(car);
	}
};

```

  比如对于这样的一段代码，在静态分派时，编译器根据静态类型和方法参数确定了方法为Car.sayHello(Car);。并生成了相应的invokevirtual指令，这里就是属于多分派。

  在程序实际执行过程中，编译器已经决定了方法必须是sayHello(Car),在invokevirtual执行时，jvm只判断方法的实际接收者类型是Benz还是Car，这就是一个典型的单分派过程。

  到java1.8为止，java依然是动态单分派语言。

#### 分派的实现

  

  仔细考虑一下就能想到，用一个遍历元数据的方法去实现对方法版本的查找肯定不是一个商业虚拟机的实现方式。为了使性能更加优越，虚拟机常用手段是以建立虚方法表的方式来加快搜索。虚方法表一般是存储在方法区中，每个表对应一个类，里面存储了各个方法的实际入口地址，如果一个子类没有重写父类的方法，那么它的虚方法表中的地址就是父类方法表中的那个对应方法的地址，且在父子类虚方法表中相同签名的方法有同样的索引号。（回忆一下的话，class文件中是不会包含未重写的父类方法的，虚方法表和class文件的存储method_info的数据区不同）

  虚方法表在类加载的准备阶段（类变量默认值赋值完成后）初始化。

  虚方法表只是一种优化方式，商用虚拟机为了保证最高的效率肯定做了其他优化。

  