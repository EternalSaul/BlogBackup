---
title: 'JVM(3):类加载过程'
date: 2017-12-04 12:41:21
toc: true
tags:
 - JVM
 - 学习笔记
---

  一般来说，我们以.class文件的形式将类保存到磁盘上，在介绍类结构的时候我已经说了，jvm并不关系你的类从哪儿来，只要它符合jvm类结构的规范就好了，无论是以传统方式从磁盘上加载.class文件，还是从网络来获取一段流，亦或者以Proxy动态生成一个类，都没有问题，它们最终会被自己所属的**类加载器**加载到虚拟机的方法区中，成为jvm可以直接使用的java类型。

  类的生命周期有7个阶段，它们分别是：

`加载->验证->准备->解析->初始化->使用->卸载`

其中`验证->准备->解析`这三个阶段被称为链接（Linking）阶段

`加载->验证->准备->解析->初始化`这5个阶段称为**类加载阶段**

  在上面的声明周期七个阶段中，**加载，验证，准备，初始化，卸载**这5个阶段是**按顺序开始**的，注意这里是只是说开始，实际上它们的执行过程是**交叉进行**，相当于你按顺序执行了一个线程，线程里又执行了一个新的线程，如此往复的执行了5个，实际上它们是交叉执行的。

  上面的**箭头部分有误导倾向**，因为**解析**这个过程，为了支持Java的运行时绑定机制，**有些时候在初始化过程之后开始**。

<!--more-->

  [虚拟机规范](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5)并没有规定加载阶段在什么时候开始，但是它规定了初始化阶段，**有且只有**在以下**6种情况（Java1.8中）**下必须立刻执行，当然我们上面提到过的，初始化阶段必须在**加载，验证，准备**之后才能执行，所以那个时候其实已经开始了前三个阶段了，类初始化实际上就是执行clinit方法，下面列出这六种情况，**如果类没有被初始化，那么先初始化**：

  1.遇到new,getstatic,putstatic,invokestatic四条字节码指令时，比如new一个对象，或者获取或修改一个类的静态变量

  2.使用了某些反射方法对类进行反射调用，比如Class类中或者java.lang.reflect包中的某些方法

  3.初始化一个类时，发现其父类没有被初始化，那么先初始化父类

  4.一个被选定为虚拟机启动时初始化类的类

  5.首次调用方法句柄解析结果是REF_getStatic, REF_putStatic, REF_invokeStatic,REF_newInvokeSpecial这几种类型的 java.lang.invoke.MethodHandle实例，且方法句柄所对应的类没有被初始化

  6.如果一个接口声明了一个非抽象且非静态的方法，在初始化它的实现类之前应该初始化。

  以上6种情况，统称为对一个类进行主动引用，有主动引用就有被动引用，被动引用不会触发对类的初始化，比如如下几种情况的代码：

```
----------案例一------------
public class Hello {
	
	public static int alpha=123;
	
	//这种区域会直接编译到clinit方法中去
	static {
		System.out.println("hello");
	}

	//注意main方法是在父类Hello中，如在子类中，会因为这个main方法导致子类初始化
	public static void main(String[] args) {
		/*
		*用子类A调用了父类中的字段alpha，
		*但是实际上A不会被初始化，从类结构上考虑下我们就可以知道为什么，
		*因为子类中根本不会有父类的字段，而父类的static在父类的clinit方法中初始化，和子类没半毛钱关系
		*/
		System.out.println(A.alpha);
	}
}


class A extends Hello {
	
	static {
		System.out.println("m");
	}
	
}

输出：
hello
123


--------------案例二----------
class Init{
	public static void main(String[] args) {
	/*
	这种情况既不会初始化A也不会初始化Hello，为什么呢？因为数组这种类是由jvm自己生成的，而且new一个数组的字节码也是newarray而不是new
	*/
		A[] hello=new A[100];
	}
}

输出：
```

## 加载

  我们首先来讨论一下**类加载**过程中的第一个阶段——**加载**，这个阶段主要就是做这样两件事情：

 1.把一个类的全限定名获取来的字节流转化为方法区的运行时数据结构

 2.在内存中（hotspot是在方法区中），生成一个代表该类的java.lang.Class对象，以作为该类各种数据的访问入口

---

**数组的加载**

对于数组而言，上面我们看到了数组这种东西是JVM自己创建的，那么它的加载方式也不同，但是对于数组的元素类型（**数组去掉所有维度对应的那个类型**）还是要用类加载器去加载的。

下面的步骤用于使用类加载器L类装载器创建由描述符N表示的数组类C，L可以是引导类加载器或用户定义类加载器。

第一步JVM判断，如果L已被记录为具有与描述符为N的类或者接口的组件类型的数组类的启动装入器，则该类是C，并且不需要创建数组类。 （就是该数组类型已经被在加载了，就不再加载）

否则，执行以下步骤以创建C：

如果组件类型（**数组去掉一个维度的类型**）是引用类型，类加载器L递归的使用这一节说到的类加载算法，从而创建的组件类型C.

java虚拟机创建一个新的显示组件类型和维数的数组类。

如果组件类型是引用类型，那么C被标记为由组件类型的定义类装入器定义的。

否则（比如int k[],这基本类型），C被标记为由引导类装入器定义的。

在以上两种的任何情况下，接下来java虚拟机都会记录L是C的类加载器。如果组件类型是引用类型，则数组类的可访问性取决于其组件类型的可访问性。否则，数组类的可访问性是公共的。 

---

  有些人可能会好奇方法区中怎么存储类，这个问题我可能会写一篇新的文章来说明，目前我们只讨论类加载过程，实际上JVM规范是没有给出方法区以什么数据结构出现的，但是我们可以在未来讨论一下Hotspot中的实现，正如上面所说的，Hotspot会在方法区中创建一个标识类的java.lang.Class对象。

## 链接

  我们把验证，准备，解析3个阶段统称为链接阶段，链接阶段是与加载阶段交替进行的，即一边加载一边链接。

### 验证

  首先我们来看看验证阶段，这个阶段并不是运行是必须的，你完全可以不验证类，只要你保证它一定是符合虚拟机规范正常运行的，比如对于一些软件中运行了不知道多少年的类，你可以认为他们不需要浪费时间去验证，因为以前已经验证过了（验证是非常耗时的），我们可以使用-Xverify:none参数来关闭大部分类验证措施。

  虽然验证并非是必要的，但是不代表它不是重要的，它是虚拟机能够稳定运行的重要防线，我们虽然会浪费时间对一个类进行重复的验证，不过我们也可以防止一些恶意的意想不到的字节流对我们的虚拟机造成不可预测的破坏。

  如果验证阶段验证到字节流不符合Class规范，那么虚拟机会抛出java.lang.VerifyError或者其子异常。

以HotSpot验证过程大概分为四个部分：

1.文件结构验证

  这个阶段是验证里唯一一个基于二进制字节流的阶段，通过了该阶段之后字节流就变成方法区的数据结构了，该阶段主要是验证像魔术，版本，是否符合UTF8编码等等不需要语义分析的验证。

2.元数据验证

  这个阶段主要是对类的继承，抽象等等语义进行验证，即对类的元数据进行语义验证

3.字节码验证

  主要通过数据流和控制流分析看程序语义是否合法，还有就是对方法体进行校验，在上篇文章中我们提到的额StackMapTable属性就是在这个阶段中使用的，它描述了方法体中所有的基本代码块开始是本地变量表和操作数栈应有的关系，验证期间对着它来推导状态的合法性。

4.符号引用验证

  这个阶段的验证发生在解析阶段中，主要对符号引用转化为直接引用的可行性进行验证，如果通过不了就会抛出一个java.lang.IncompatibleClassChangeError异常的子类型。

### 准备

  该阶段涉及到为类创建静态字段（static fields）并为他们设置初始值。

  这里的初始值并不是指用户在诸如`static int k=1; `这样的语句中设定的k的值为1（这个阶段是clinit做的）,而是对于int类型给定初始值为0，对boolean则是为false，对reference则是null，等等。

### 解析

  解析阶段即是**虚拟机将常量池内的符号引用替换为直接引用的过程**。

  JVM中*anewarray*, *checkcast*, *getfield*, *getstatic*, *instanceof*,* invokedynamic*, *invokeinterface*, *invokespecial*, *invokestatic*,*invokevirtual*, *ldc*, *ldc_w*, *multianewarray*, *new*, *putfield*,  *putstatic*都把符号引用映射到在运行时常量池（run-time constant pool），所以在执行这些语句之前都需要先执行对应符号引用的解析。

  对于除了invokedynamic之外的指令，对同一个符号引用的多次解析是非常平常的，因此虚拟机会把第一次解析结果进行缓存，从而实现只解析一次，实际操作方式是在运行时常量池中把直接引用标记为已解析状态。这样一来如果一个符号以前被正确解析过，那么解析请求就应当一直成功，如果第一次失败了，那么后续失败抛出的异常也应该相同。这些指令都可以在刚刚完成加载阶段就开始解析。

  对应invokedynamic来说，它是要等到程序运行到这条指令才开始解析，所以我们说类的解析阶段不固定，可能是在初始化之后才完成也说不定。当碰到前面某个已经由invokedynamic触发过解析的符号引用时，并不意味着该解析结果对于其他的invokedynamic同样适用。

  解析动作主要针对7中符号：

  类和接口，字段，类方法，接口方法，方法类型，方法句柄以及调用点

#### 类和接口解析

对类和接口的解析我们这样来描述：

 如果当前代码所属类D，现在要解析一个未解析的符号N为一个类或者接口的直接引用，那么：

1. 如果C不是数组，那么VM把代表N的权限定名给用D的类加载器，然后D的类加载器去加载C。
2. 如果C是数组则按照第一点加载数组的元素类型。接着虚拟机生成一个代表此数组维度和元素的数组对象

   3.上面的步骤正常执行完，那么最后进行符号引用验证，确认D是否具备对C的访问权，不具备就抛出java.lang.IllegalAccessError。

#### 字段解析

  解析一个未被解析过的字段的符号引用，首先对该字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析（即先解析这个对应的类，参照上面的对类和接口的解析）。

如果C本身就包含了简单名称和字段描述符的字段都与目标相匹配的字段，则字段查找成功。返回这个字段的直接引用，查找结束。

否则，如果C定义了接口那么会按照继承关系递归的搜索各个接口和他的父接口，如果接口中包含了简单名称和字段的全部描述符都于目标相匹配的字段，则返回这个字段的直接引用，查找结束。

否则，如果C不是java.lang.Object就递归搜索其父类，如果父类中包含了简单名称和字段描述都与目标相匹配的字段，则返回该字段的直接引用，查找结束。

否则，字段查找失败，抛出java.lang.NoSuchFieldError异常

上面的步骤正常执行完，那么最后进行符号引用验证，上下文是否具备对字段的访问权，不具备就抛出java.lang.IllegalAccessError。

#### 类方法解析

  第一步先解析出类方法表中class_index所属的**类引用**,我们用C代表这个类。

  这里首先明确一点类方法和接口方法引用的常量定义是分开的，如果类方法表中class_index指向一个接口的索引就抛出java.lang.IncompatibleClassChangeError异常。

  如果C中有简单名称和描述符都相匹配的方法，有则返回该方法的直接引用，查找结束。

  否则递归寻找父类中是否有简单名称和描述符都相匹配的方法，有则返回该方法的直接引用，查找结束。

  否则递归寻找C实现的接口即接口的父接口中简单名称和描述符都相匹配的方法，有则说明C是抽象类，抛出java.lang.AbstractMethodError异常。

  否则肯定查找失败了，直接抛出java.lang.IllegalAccessError。

  上面的步骤正常执行完，那么最后进行符号引用验证，上下文是否具备对方法的访问权，不具备就抛出java.lang.IllegalAccessError。

#### 接口方法解析

第一步先解析出类方法表中class_index所属的**接口引用**,我们用C代表这个接口。

  这里首先明确一点类方法和接口方法引用的常量定义是分开的，如果类方法表中class_index指向一个类的索引就抛出java.lang.IncompatibleClassChangeError异常。

  如果C中有简单名称和描述符都相匹配的方法，有则返回该方法的直接引用，查找结束。

  否则递归寻找C的父接口中简单名称和描述符都相匹配的方法，直到找到java.lang.Object类， 如果找到有简单名称和描述符都相匹配的方法，有则返回该方法的直接引用，查找结束。

  否则肯定查找失败了，直接抛出java.lang.NoSuchMethodError异常

  接口中的方法默认都是public和static的,不存在访问权限问题。

## 初始化

  初始化阶段(Initialization)一般是类加载的最后一步(解析阶段有时候可能在这之后发生)，我们知道在链接过程中的准备阶段，我们的类变量就已经赋了类型默认值，但是`static int k=3;`这个3是的赋值就是发生在初始化阶段的,准确来说它发生在类构造器clinit方法执行的过程中。

  我们在讨论类的方法表的时候说过，编译器可能会自动给你加一些你没有写过的方法，比如类构造器就是一个这样的方法。

  编译器自动收集类中所有的类变量的赋值动作和静态代码块(static标注)，这个顺序由Java源代码给出的顺序决定，这里有一个很有意思的经常出面试题的部分，就是**static块对出现在它之前类变量可以赋值但是不可以访问**

比如：

```
public class Hello {
	static {
		alpha=1;
		System.out.println(alpha);//该句报错
	}
	public static int alpha=124;
}

//如果改为，则没问题
class A extends Hello {
	public static int alpha=124;
	static {
		alpha=1;
		System.out.println(alpha);
	}
}
```

  第二点要注意的就是，clinit不需要现实的调用父类的clinit，它会自动保证在执行子类的类构造器方法前已经执行了父类的类构造器。

  一个**类或者接口**中根本没有静态语句块和对静态变量赋值操作那么编译器可以不生成clinit方法，注意接口也可能有clinit来做对静态变量的初始化操作。

  VM会自动保证clinit方法在多线程环境中的同步和加锁操作，只能有一个线程去执行clinit，且同一个类加载器下，一个类型只会初始化一次，所以即使有多个线程同时执行这个类型的clinit，也只会有一个线程执行成功。

  