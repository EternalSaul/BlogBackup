---
title: 'Functional Programming (1):函数式编程概念'
date: 2017-07-27 13:59:43
toc: true
tags:
 - scala
 - FP
---

## 函数式编程崛起

### Why?

  在大学低年级的时候，我们可能听的最多的就是面向过程编程以及面向对象编程，并且这两种编程模型我们会在学习中不断的使用，近年来，我们可以看到计算机的核心数不断的增加，随着并发的概念越来越深入软件系统，数据处理的规模越来越大，在你学操作系统的时候，你接触到的信号量，死锁检测等等手段在实际应用中可能对很多程序员是一个挑战，于是函数式编程又一次出现在了工程界，14年迟迟发布的java 8中，Java引入了lambda表达式，似乎标志工程界命令式编程（imperative programming）和声明式编程（Declarative programming ）互相交织的时代已经全面正式的拉开大幕。

### 函数式编程概念

  **那么什么是函数式编程（Functional Programming）？**

  **函数式编程是一种编程范式，它是声明式编程（用表达式或声明来代替语句块）的一种，它倾向于计算像求解数学函数一样，避免改变状态和使用可变量，在函数式代码中，函数的输出仅依赖于传入的参数，同样的输入意味着同样的输出，和局部或全局状态无关 。**

  函数式编程的输入和传参的依赖特性使得，使得函数更加容易理解和可预测，因为你不需要再去思考有函数输入参数之外的其他的状态，影响函数的输出。比如调用函数时你不需要考虑是不是会出现线程同步问题（这样说威力够大？）。

<!--more-->

## 函数式编程特点

### 纯函数

  **一个函数没有副作用(side effect)，就称它是纯函数。**

举个例子：

​    y=cos(x)

  这里列举出的余弦函数，就没有副作用，无论是何时何地使用它，除了输入和输出结果没有和外部产生任何数据交换。

  **纯函数和外界交换数据的唯一渠道，就是通过用于输入所有信息到函数内部的参数值和用于输出所有信息到函数外部的返回值**



一般来说一个有意义的无返回值的函数，都是有副作用的，比如：

```scala
scala> def hello(){println("hello")}
hello: ()Unit
```

  虽然hello函数只是输出了一个hello字符串，但它却是有副作用的，因为输出了一个字符串到屏幕上修改了函数hello以外的事务的状态。

### 引用透明

  引用透明（Referential transparency）是指一个表达式可以被它的对应值（corresponding value）取代而不改变程序的行为。

  **如果一个函数调用时传入的参数是引用透明的，并且函数调用也是引用透明的，那么这个函数是一个纯函数。**

  函数式程序没有赋值语句块，变量的值一旦定义就不能被改变，任何变量都可以在执行的任何一个点上被替换为实际的值，所以函数式程序是引用透明的。

  如果一个表达式不是引用透明的，那么它就被成为是引用不透明（referential opaque）。

### 惰性求值

  函数式语言可以被分类为严格（strict）求值和非严格（non-strict）求值,可以称之为立即求值（eager evaluation）和惰性求值（lazy evaluation）。

  在立即求值中，**表达式绑定到变量后立即求值**，这也是大多数经典语言的做法。相对的惰性求值是指，**按需调用，一个表达式再绑定到变量后，不立即求值而是等到这个变量要被使用时才执行求值，但是它并不重复调用表达式，当计算一次以后，变量的值便已经确定。**

```scala
//声明一个懒值，该表达式是引用不透明的
scala> lazy val x={println("kkk");8-5+3}
x: Int = <lazy>

//可以看到当使用x时，绑定到x的表达式才执行
scala> x
kkk
res0: Int = 6

//再次使用x，表达式并不输出
scala> x
res1: Int = 6
```



### 递归

  迭代在函数式语言中常用递归来完成，用递归来实现控制流程的机制是函数式编程的一个非常重要的特点。

  一般来说递归需要维护一个栈这会导致额外的开销，比如说经典的斐波拉切数列的求解，我们很喜欢用递归来完成，但是仔细研究过的同学可以发现其实一般递归方式实现斐波拉契数列到一定的程度，会发生栈溢出，并且它的时间效率也不高，它总是重复计算相同的值，很多算法数上用这个例子来介绍动态规划算法的优势，如果你想使用递归，又想改善效率，我们其实可以使用尾递归。

  尾递归的实现其实是基于编译器的识别和优化的，编译器发现一个函数是尾递归的就会把它实现为与命令式编程中的迭代差不多的汇编码。

### 高阶函数和First-class函数

[该特性可以查看我的另一篇文章](/2017/07/05/Learning-Scala-1-Function/)



### 函数式数据结构

  由于函数性编程强调不可变性（immutability），函数式编程中的数据结构常常异于他们在命令式编程中的实现，像数组这样在命令式编程中最常见的数据结构，在函数式编程中可以用map和随机存取链表来代替，有时他们可能不如可变结构那么高效，但是在纯函数式编程中你不得不考虑，只使用纯函数的话有些结构是不可以实现的，所以有时候你可以看到诸如向scala这样的语言，提供了可变和不可变两种结构，并且他们可以相互转化，以至于在某些比较大的工程场景能够派上用场。















